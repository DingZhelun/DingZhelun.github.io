<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Tensorflow学习]]></title>
    <url>%2F2019%2F10%2F10%2F%E8%BF%87%E6%8B%9F%E5%90%88%2F</url>
    <content type="text"><![CDATA[Tensorflow学习《Tensorflow：实战Google深度学习框架》 为了避免过拟合问题，非常常用的方法是：正则化 正则化的思想就是在损失函数中加入刻画模型复杂程度的指标。 假如用于刻画模型在训练数据上表现的损失函数为J(θ),那么在优化时不是直接优化J(θ)，而是优化J(θ)+λR(w)。其中R(w)刻画的是模型的复杂程度，而λ表示模型复杂损失在总损失中的比例。θ表示的是一个神经网络中的所有的参数，它包括边上的权重w和偏置项b。一般来说模型的复杂程度只由权重w决定。常用的刻画模型复杂程度的函数R(w)有两种 一种是L1正则化，计算公式是:$R(w)=||{w}||=\sum\limits_i$ R(w)=||{w_i}||=\sum\limits_i公式呢？2]]></content>
  </entry>
  <entry>
    <title><![CDATA[点云数据格式]]></title>
    <url>%2F2019%2F09%2F21%2F%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[PCD+PLY PCD格式文件头格式现有的文件结构因本身组成的原因不支持由PCL库引进n维点类型机制处理过程中的某些扩展，而PCD文件格式能够很好地补足这一点。PCD不是第一个支持3D点云数据的文件类型，尤其是计算机图形学和计算几何学领域，已经创建了很多格式来描述任意多边形和激光扫描仪获取的点云。包括下面几种格式： PLY是一种多边形文件格式，由Stanford大学的Turk等人设计开发； STL是3D Systems公司创建的模型文件格式，主要应用于CAD、CAM领域； OBJ是从几何学上定义的文件格式，首先由Wavefront Technologies开发； X3D是符合ISO标准的基于XML的文件格式，表示3D计算机图形数据； 其他许多种格式。 以上所有的文件格式都有缺点，在下一节会讲到。这是很自然的，因为它们是在不同时间为了不同的使用目的所创建的，那时今天的新的传感器技术和算法都还没有发明出来。 每一个PCD文件包含一个文件头，它确定和声明文件中存储的点云数据的某种特性。PCD文件头必须用ASCII码来编码。PCD文件中指定的每一个文件头字段以及ascii点数据都用一个新行（\n）分开了，从0.7版本开始，PCD文件头包含下面的字段： VERSION –指定PCD文件版本 FIELDS –指定一个点可以有的每一个维度和字段的名字。例如： 123456789FIELDS x y z # XYZ dataFIELDS x y z rgb # XYZ + colorsFIELDS x y z normal_xnormal_y normal_z # XYZ + surface normalsFIELDS j1 j2 j3 # moment invariants... SIZE –用字节数指定每一个维度的大小。例如： 1234567unsigned char/char has 1 byteunsigned short/short has 2 bytesunsignedint/int/float has 4 bytesdouble has 8 bytes TYPE –用一个字符指定每一个维度的类型。现在被接受的类型有 12345I – 表示有符号类型int8（char）、int16（short）和int32（int）；U – 表示无符号类型uint8（unsigned char）、uint16（unsigned short）和uint32（unsigned int）；F – 表示浮点类型。 COUNT –指定每一个维度包含的元素数目。例如，x这个数据通常有一个元素，但是像VFH这样的特征描述子就有308个。实际上这是在给每一点引入n维直方图描述符的方法，把它们当做单个的连续存储块。默认情况下，如果没有COUNT，所有维度的数目被设置成1。 WIDTH –用点的数量表示点云数据集的宽度。根据是有序点云还是无序点云，WIDTH有两层解释： 它能确定无序数据集的点云中点的个数（和下面的POINTS一样） 它能确定有序点云数据集的宽度（一行中点的数目） 注意：有序点云数据集，意味着点云是类似于图像（或者矩阵）的结构，数据分为行和列。这种点云的实例包括立体摄像机和时间飞行摄像机生成的数据。有序数据集的优势在于，预先了解相邻点（和像素点类似）的关系，邻域操作更加高效，这样就加速了计算并降低了PCL中某些算法的成本。 例如： WIDTH 640 # 每行有640个点 HEIGHT –用点的数目表示点云数据集的高度。类似于WIDTH ，HEIGHT也有两层解释： 它表示有序点云数据集的高度（行的总数） 对于无序数据集它被设置成1（被用来检查一个数据集是有序还是无序） 有序点云例子： WIDTH 640 # 像图像一样的有序结构，有640行和480列， HEIGHT 480 # 这样该数据集中共有640*480=307200个点 无序点云例子： WIDTH 307200 HEIGHT 1 # 有307200个点的无序点云数据集 VIEWPOINT–指定数据集中点云的获取视点。VIEWPOINT有可能在不同坐标系之间转换的时候应用，在辅助获取其他特征时也比较有用，例如曲面法线，在判断方向一致性时，需要知道视点的方位，视点信息被指定为平移（txtytz）+四元数（qwqxqyqz）。 默认值是：VIEWPOINT 0 0 0 1 0 0 0 POINTS–指定点云中点的总数。从0.7版本开始，该字段就有点多余了，因此有可能在将来的版本中将它移除 例子： POINTS 307200 #点云中点的总数为307200 DATA –指定存储点云数据的数据类型。从0.7版本开始，支持两种数据类型：ascii和二进制。 注意：文件头最后一行（DATA）的下一个字节就被看成是点云的数据部分了，它会被解释为点云数据。 警告：PCD文件的文件头部分必须以上面的顺序精确指定，也就是如下顺序： VERSION、FIELDS、SIZE、TYPE、COUNT、WIDTH、HEIGHT、VIEWPOINT、POINTS、DATA 之间用换行隔开。 数据存储类型在0.7版本中，.PCD文件格式用两种模式存储数据： 如果以ASCII形式，每一点占据一个新行： 1234567p_1p_2...p_n 注意：从PCL 1.0.1版本开始，用字符串“nan”表示NaN，此字符表示该点的值不存在或非法等。 如果以二进制形式，这里数据是数组（向量）pcl::PointCloud.points的一份完整拷贝，在Linux系统上，我们用mmap/munmap操作来尽可能快的读写数据，存储点云数据可以用简单的ascii形式，每点占据一行，用空格键或Tab键分开，没有其他任何字符。也可以用二进制存储格式，它既简单又快速，当然这依赖于用户应用。ascii格式允许用户打开点云文件，使用例如gunplot这样的标准软件工具更改点云文件数据，或者用sed、awk等工具来对它们进行操作。 相对其他文件格式的优势用PCD作为（另一种）文件格式可能被看成是没有必要的一项工作。但实际中，情况不是这样的，因为上面提到的文件格式无一能提高PCD文件的适用性和速度。PCD文件格式包括以下几个明显的优势： 存储和处理有序点云数据集的能力——这一点对于实时应用，例如增强现实、机器人学等领域十分重要； 二进制mmap/munmap数据类型是把数据下载和存储到磁盘上最快的方法； 存储不同的数据类型（支持所有的基本类型：char，short，int，float，double）——使得点云数据在存储和处理过程中适应性强并且高效，其中无效的点的通常存储为NAN类型； 特征描述子的n维直方图——对于3D识别和计算机视觉应用十分重要。 另一个优势是通过控制文件格式，我们能够使其最大程度上适应PCL，这样能获得PCL应用程序的最好性能，而不用把一种不同的文件格式改变成PCL的内部格式，这样的话通过转换函数会引起额外的延时。 注意：尽管PCD（点云数据）是PCL中的内部文件格式，pcl_io库也提供在前面提到的所有其他文件格式中保存和加载数据。 例子下面贴出了PCD文件的一个片段。把它留给读者以解析这些数据，看看它的组成，玩的愉快！ 12345678910111213# .PCD v.7 - Point Cloud Data file formatVERSION .7FIELDS x y z rgbSIZE 4 4 4 4TYPE F FFFCOUNT 1 1 1 1WIDTH 213HEIGHT 1VIEWPOINT 0 0 0 1 0 0 0POINTS 213DATA ascii0.93773 0.33763 0 4.2108e+060.90805 0.35641 0 4.2108e+06 PLY——多边形文件格式也被称为斯坦福三角格式 足够简单 典型的PLY对象定义仅仅是顶点的（x，y，z）三元组列表和由顶点列表中的索引描述的面的列表 文件结构这是一个典型的PLY文件的结构： 1234Header Vertex List Face List (lists of other elements) 标题是一系列回车终止的文本行，描述文件的其余部分。 标题包括每个元素类型的描述，包括元素的名称（例如“边”），对象中有多少这样的元素以及与该元素相关联的各种属性的列表。 在标题之后是每个元素类型的元素列表，按照标题中描述的顺序呈现 12345678910111213141516171819202122232425plyformat ascii 1.0 &#123; ascii/binary, format version number &#125;comment made by Greg Turk &#123; comments keyword specified, like all lines &#125;comment this file is a cubeelement vertex 8 &#123; define &quot;vertex&quot; element, 8 of them in file &#125;property float x &#123; vertex contains float &quot;x&quot; coordinate &#125;property float y &#123; y coordinate is also a vertex property &#125;property float z &#123; z coordinate, too &#125;element face 6 &#123; there are 6 &quot;face&quot; elements in the file &#125;property list uchar int vertex_index &#123; &quot;vertex_indices&quot; is a list of ints &#125;end_header &#123; delimits the end of the header &#125;0 0 0 &#123; start of vertex list &#125;0 0 10 1 10 1 01 0 01 0 11 1 11 1 04 0 1 2 3 &#123; start of face list &#125;4 7 6 5 44 0 4 5 14 1 5 6 24 2 6 7 34 3 7 4 0 此示例演示了标题的基本组件。 标题的每个部分都是以关键字开头的回车终止的ASCII字符串。 即使标头（“ply”和“end_header”）的开头和结尾都是这种形式。 字符“ply”必须是文件的前四个字符，因为它们作为文件的魔术数字。 12345element property property property ... 在“元素”行之后列出的属性定义属性的数据类型以及属性为每个元素显示的顺序。 属性可能有两种类型的数据类型：标量和列表。 以下是属性可能具有的标量数据类型的列表： 12345678910name type number of bytes---------------------------------------char character 1uchar unsigned character 1short short integer 2ushort unsigned short integer 2int integer 4uint unsigned integer 4float single-precision float 4double double-precision float 8 这些字节计数是重要的，并且不能在实现之间变化，以便这些文件可移植。 有一种使用列表数据类型的特殊形式的属性定义： property list 一个例子是上面的立方体文件： property list uchar int vertex_index 这意味着属性“vertex_index”首先包含一个无符号字符，表示该属性包含多少个索引，后跟一个包含多个整数的列表。 此变长列表中的每个整数都是顶点的索引。 另一个例子这是另一个立方体定义： 12345678910111213141516171819202122232425262728293031323334353637383940plyformat ascii 1.0comment author: Greg Turkcomment object: another cubeelement vertex 8property float xproperty float yproperty float zproperty uchar red &#123; start of vertex color &#125;property uchar greenproperty uchar blueelement face 7property list uchar int vertex_index &#123; number of vertices for each face &#125;element edge 5 &#123; five edges in object &#125;property int vertex1 &#123; index to first vertex of edge &#125;property int vertex2 &#123; index to second vertex &#125;property uchar red &#123; start of edge color &#125;property uchar greenproperty uchar blueend_header0 0 0 255 0 0 &#123; start of vertex list &#125;0 0 1 255 0 00 1 1 255 0 00 1 0 255 0 01 0 0 0 0 2551 0 1 0 0 2551 1 1 0 0 2551 1 0 0 0 2553 0 1 2 &#123; start of face list, begin with a triangle &#125;3 0 2 3 &#123; another triangle &#125;4 7 6 5 4 &#123; now some quadrilaterals &#125;4 0 4 5 14 1 5 6 24 2 6 7 34 3 7 4 00 1 255 255 255 &#123; start of edge list, begin with white edge &#125;1 2 255 255 2552 3 255 255 2553 0 255 255 2552 0 0 0 0 &#123; end with a single black line &#125; 该文件为每个顶点指定一个红色，绿色和蓝色的值。 为了说明vertex_index的可变长度属性，对象的前两个面是三角形，而不是单个正方形。 这意味着对象中的面数是7.这个对象还包含一个边列表。 每个边包含两个指向边缘的顶点的指针。 每个边缘也有一个颜色。 指定了上面定义的五个边，以突出显示文件中的两个三角形。 前四个边是白色的，它们围绕着两个三角形。 最后的边缘是黑色的，它是分隔三角形的边。 用户定义的元素上面的例子显示了使用三个元素：顶点，面和边。 PLY格式允许用户自己定义元素。 用于定义新元素的格式与顶点，面和边缘完全相同。 以下是定义材质属性的标题部分： 1234567891011121314element material 6property ambient_red uchar &#123; ambient color &#125;property ambient_green ucharproperty ambient_blue ucharproperty ambient_coeff floatproperty diffuse_red uchar &#123; diffuse color &#125;property diffuse_green ucharproperty diffuse_blue ucharproperty diffuse_coeff floatproperty specular_red uchar &#123; specular color &#125;property specular_green ucharproperty specular_blue ucharproperty specular_coeff floatproperty specular_power float &#123; Phong power &#125; 这些线将直接在顶点，面和边的规范之后出现在标题中。 如果我们希望每个顶点都有一个材质规范，我们可以将这一行添加到顶点属性的末尾： 1property material_index int 该整数现在是包含在文件中的材料列表的索引。一个新的应用程序的作者可能会发现几个要存储在PLY文件中的新元素。这种做法应该保持在最低限度。更好的是尝试将常用元素（顶点，面，边缘，材质）修改为新的用途，以便了解这些元素的其他程序可能有助于处理这些适应的元素。例如，将分子描述为球体和圆柱体的集合的应用程序。对于包含分子的PLY文件，将是诱人的定义球体和圆柱体元素。但是，如果我们为此使用顶点和边缘元素（将radius属性添加到每个元素），我们可以使用操纵和显示顶点和边的程序。显然，不应该为三角形和四边形创建特殊元素，而是使用面元素。如果程序不知道面和顶点之间的邻接（所谓的非共享顶点）怎么办？这就是每个三角形（说）纯粹是空间中三个位置的集合，没有概念是否有一些三角形有共同的顶点。这是一个相当普遍的情况。假设给定对象中有N个三角形，则应将3N顶点写入文件，然后再将N个面简单地连接到这些顶点。我们预计将编写一个在非共享和共享顶点文件之间进行转换的实用程序。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Pointnet++理解]]></title>
    <url>%2F2019%2F09%2F17%2Fpointnet-%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/sinat_37011812/article/details/81945050 简介作者在先前的研究中提出Pointnet，此论文是Pointnet的改进版Pointnet++。提出改进的理由是因为Pointnet无法很好地捕捉由度量空间引起的局部结构问题，由此限制了网络对精细场景的识别以及对复杂场景的泛化能力。 Pointnet的基本思想是对输入点云中的每一个点，学习其对应的空间编码，之后再利用所有点的特征得到一个全局的点云特征，这里欠缺了对局部特征的提取及处理，比如说点云空间中临近点一般都具有相近的特征，同属于一个物体空间中的点的概率很大，就好比二维图像中，同一个物体的像素值都相近一样。 再者现实场景中的点云往往是书迷不同的，而Pointnet是基于均匀采样的点云进行训练的，导致了其在实际场景点云中的准确率下降。 Pointnet++就上述提出了改进，解决了两个问题： 如何对点云进行局部划分 如何对点云进行局部特征提取 上述两个问题其实是相互关联的。 实现细节 层级点云特征学习点集的特征提取由三部分组成，分别为Sampling layer、Grouping layer、Pointnet layer。 Sampling layer采样层在输入点云中选择一系列点，由此定义出局部区域的中心。采样算法使用迭代最远点采样方法iterative farthest point sampling（FPS）。FPS：先随机选择一个点，然后再选择离这个点最远的点作为起点，再继续迭代，知道选出需要的个数为止。 相比随机采样，能更完整的通过区域中心点采样到全局点云 Grouping layer目的是要构建局部区域，进而提取特征。思想就是利用临近点，并且论文中使用的是neighborhood ball，而不是KNN，是因为可以保证有一个fixed region scale，主要的指标还是距离distance。 Pointnet layer在如何对点云进行局部特征提取的问题上，利用原有的Pointnet就可以很好的提取点云的特征，由此在Pointnet++中，原先的Pointnet网络就成为了Pointnet++网络中的子网络，层级迭代提取特征。 点云密度不均匀时的鲁棒特征学习这里作者解决空间中点云的密度不均匀对特征学习带来的挑战，提出了两种grouping的方法，即如何提取不同尺度的局部patterns并按照局部点的密度去组合它们。称为密度自适应层 Multi-scale Grouping简单而有效的方式，直接对不同密度的点云特征（通过Pointnet提取后的）进行组合 不同密度的点云时通过对输入点云进行不同概率的dropout得到的 问题是计算量比较大 Multi-resolution Grouping分两部分，一部分直接用Pointnet从raw points上提取特征，另一部分是对subregion使用set abstraction得到的特征的集合。第一部分想当于是一个比较全局的部分，第二部分相当于是一个比较局部的部分，这里用两部分可以很好的控制全局区域密度。当局部区域密度比较小时，说明全局特征没有全局特征可靠，因此可以增加全局特征的权重。反之也是如此。这就相当于权重可以在密度的变化之中可以被学习到。 Segmentation在网络中输入不断被降采样而在segmentation中label都是针对原始点的，相当于需要做一个upsampling的动作。作者使用插值的方法再和之前的set abstraction中的feature做一个concatenate，inverse distance weighted average based on k nearest neighbors 结论Pointnet++的结构在3D point clouds上取得了state of art的水平，解决了如何处理采样不均匀的问题，也考虑了空间中点与点之间的距离度量，通过层级结构利用局部区域信息学习特征，网络结构更有效更鲁棒。]]></content>
      <tags>
        <tag>Pointnet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令]]></title>
    <url>%2F2019%2F09%2F14%2Flinux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一些用到的Linux命令 清华镜像pip install -i https://pypi.tuna.tsinghua.edu.cn/simple top命令TOP是一个动态显示过程,即可以通过用户按键来不断刷新当前状态。如果在前台执行该命令,它将独占前台,直到用户终止该程序为止。比较准确的说,top命令提供了实时的对系统处理器的状态监视。它将显示系统中CPU最“敏感”的任务列表。该命令可以按CPU使用。内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。 nvidia-smi 命令nvidia-smi 查看gpu的使用情况：]]></content>
      <tags>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PointNet理解]]></title>
    <url>%2F2019%2F08%2F16%2FPointNet%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[初学pointnet，一些重点笔记 一、三维深度学习简介 多视角（multi-view）：通过多视角二维图片组合三维物体，此方法将传统CNN应用于多张二维视角的图片，特征被view pooling procedure聚合起来形成三维物体 体素（volumetric）：通过将物体表现为空间中的体素进行类似于二维的三维卷积（例如，卷积核大小为5*5*5），是规律化的并且易于类比二维的，但同时因为多了一个维度出来，时间和空间复杂度都非常高，目前已经不是主流的方法了 点云（point clouds）：直接将三维点云抛入网络进行训练，数据量小。主要任务有分类、分割以及大场景下的语义分割 非欧式（manifold graph）：在流形或图的结构上进行卷积，三维点云可以表现为mesh结构，可以通过点对之间临接关系表现为图的结构。流形表达比较抽象，用到拉普拉斯特征什么的 二、点云存在的问题1.无序性：点云本质上是一长串店（n*3矩阵，其中n是点数）。在几何上，点的顺序不影响它在空间中对整体形状的表示，例如，相同的点云可以由两个完全不同的矩阵表示。如下图左边所示： 我们希望得到的效果图如下图右边：N代表点云个数，D代表每个点的特征维度，不论点云顺序怎样，希望得到相同的特征提取结果 我们知道，网络的一般结构是：提取特征-特征映射-特征图压缩（降维）-全连接 下图中x代表点云中的某个点，h代表特征提取层，g叫做对称方法，r代表更高维特征提取，最后接一个sofmax分类。g可以是maxpooling或sumpooling，也就是说，最后的D维特征对每一维都选取N个点中对应的最大特征值或特征值总和，这样就可以通过g来解决无序性问题。pointnet采用了max-pooling策略 2.旋转性：相同的点云在空间中经过了一定的刚性变化（旋转或平移），坐标发生变化，如下图所示： 我们希望不论点云在怎样的坐标系下呈现，网络都能正确的识别出。这个问题可以通过STN(spacial transform networks)来解决。二维的变换方法可以参考这里，三维不太一样的是点云是个不规则的结构（无序，无网格），不需要重采样过程。pointnet通过学习一个矩阵来达到对目标最有效的变换。 三、pointnet网络结构详解先来看看网络的两个亮点： 空间变换网络（STN）解决旋转问题：三维的STN可以通过学习点云本身的位姿信息学习到一个最有利于网络进行分类或分割的D*D旋转矩阵（D代表特征维度，pointnet中D采用3和64）。至于其中的原理，我的理解是，通过控制最后的loss来对变换矩阵进行调整，pointnet并不关心最后真正做了什么变换，只要有利于最后的结果都可以。pointnet采用了两次STN，第一次input transform是对空间中的点云进行调整，直观上理解是旋转出一个更有利于分类或分割的角度，比如，把物体转到正面；第二次feature transform是对提取出的64维特征进行对齐，即在特征层面对点云进行变换 maxpooling解决无序性问题：网络对每个点进行了一定程度的特征提取之后，maxpooling可以对点云的整体提取出global feature 再来看网络结构： 其中mlp是通过共享权重的卷积实现，第一层卷积核大小是13（因为每个点的维度是xyz），之后的每一层卷积核大小都是1\1。即特征提取层知识把每个点连接起来而已。经过两个STN和两个mlp之后，对每个点提取1024维特征，经过maxpooling变成1*1024的全局特征。再经过一个mlp(代码中运用全连接)得到k个score。分类网络最后接的loss是softmax 四、pointnet代码详解重点已经框出 网络模型部分 变换矩阵部分，以第一个STN为例]]></content>
      <tags>
        <tag>PointNet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度图、网格、体素、点云]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%B7%B1%E5%BA%A6%E5%9B%BE%E3%80%81%E7%BD%91%E6%A0%BC%E3%80%81%E4%BD%93%E7%B4%A0%E3%80%81%E7%82%B9%E4%BA%91%2F</url>
    <content type="text"><![CDATA[https://www.cnblogs.com/lainey/p/8547056.html 深度图Depth map 深度图是一张2D图片，每个像素都记录了从视点到遮挡物表面（遮挡物就是阴影生成物体）的距离，这些像素对应的顶点对于观察者来说是“可见的”。 Depth map中像素点记录的深度值为lenth1；然后从视点出现，计算物体顶点v到视点的距离，记为lenth2；比较二者大小，来确定“v”是否被遮挡。该术语的同义词有depth buffer，Z-buffer，Z-buffering和Z-depth。这里的“Z”是相对于相机（即视点）视图中心轴而言的，也就是相机的z轴线，而不是场景的绝对坐标中的z轴线。 用途 模拟在一个场景中的密度均匀的半透明介质效果-如雾，烟或大量的水 模拟场景表面的深度域（depth of field (DOF)） 可用于高效的变形体碰撞检测 体素（立体像素）体素或立体像素（voxel），是体积像素（volume pixel）的简称。概念上类似二维空间的最小单位——像素，像素用在二维电脑图像的视频数据上。体积像素一如其名，是数字数据于三维空间分区上的最小单位，应用于三维成像、科学数据与医学视频等领域。有些真正的三维显示器运用体素来描述他们的分辨率，举例说：可以显示512×512×512体素的显示器。 如同像素，体素本身并不含有空间中位置的数据（即他们的坐标），然而却可以从他们相对于其他体素的位置推敲，意即他们在构成单一张体积视频的数据结构中的位置。 网格多边形网络（Polygon mesh）是三维计算机图形学中表示多面体形状的顶点与多边形的集合,它也叫作非结构网格。 这些网格通常由三角形、四边形或者其他的简单凸多边形组成，这样可以简化渲染过程。但是，网格也可以包括带有空洞的普通多边形组成的物体。 非结构网格内部表示的例子有： 一组顶点的简单列表，它们带有表示那些顶点组成多边形的信息列表；另外可能带有表示空洞的附加信息 顶点列表 + 边界列表（一对索引信息）+ 连接边界的多边形列表 翼边数据结构 根据应用程序的不同所选择的数据结构也有所不同：三角形的处理要比普通多边形的处理更加简单，尤其是在计算几何中更是这样。对于优化的算法，可能需要快速访问边线或者相邻表面这样的拓扑信息，这样就需要如翼边表示这样更加复杂的结构。 点云（维基百科）点云（point cloud）是指通过3D扫描器所取得至资料形式。 扫描资料以点的型式记录，每一个点包含有三维座标，有些可能含有色彩资讯（R,G,B）或物体反射面强度。 点云数据除了具有几何位置以外，还有强度（Intensity）信息，强度信息的获取是激光扫描仪接受装置采集到的回波强度，此强度信息与目标的表面材质、粗糙度、入射角方向，以及仪器的发射能量，激光波长有关。点云也是逆向工程中通过仪器测量外表的点数据集合。 在电脑动画领域，皮克斯的玩具总动员3使用了点云技术。 点云应用深度学习面临的挑战： 非结构化数据，不变性排列，点云数据量上的变化(不同传感器上点云的数量变化很大) 点云数据方面的挑战： 缺少数据：扫描的模型通常被遮挡，部分数据丢失 噪音：所有传感器都是嘈杂的。有几种类型的噪声，包括点云扰动和异常值。这意味着一个点有一定的概率位于它被采样的地方(扰动)附近的某一半径范围内，或者它可能出现在空间的任意位置(异常值) 旋转：一辆车向左转，同一辆车向右转，会有不同的点云代表同一辆车 在点云上直接用深度学习的方法是将数据转换成体积表示，比如体素网格，然后就可以用3D滤波器来训练CNN，但是体积数据会变得非常大，3D CNN处理会非常慢，所以需要妥协到较低的分辨率，就会带来量化误差的代价。 针对无序点云数据的深度学习方法研究进展缓慢，主要有三个方面： 点云具有无序性 点云具有稀疏性 —— 在KITTI数据集中，如果把原始的激光雷达点云投影到对应的彩色图像上，大概只有3%的像素才有对应的雷达点。这种极强的稀疏性让基于点云的高层语义感知变得尤其困难。 点云信息量有限 —— 点云的数据结构就是一些三维空间的点坐标构成的点集，本质是对三维世界几何形状的低分辨率重采样，因此只能提供片面的几何信息 举例说明 iphoneX 3D结构光双摄 用的是PrimeSense的结构光深度重建方案(Depth),和普通的彩色RGB不同，深度摄像头输出的时RGBD图像，多了一个深度通道，深度图像看起来是这样的：由深度图可以得到点云，进而得到网格（mesh）效果如下： 3D 重建后的人脸，比 2D人脸多了很多信息，识别显然会更准确 由于结构光的特性，每一帧数据都能重建出完整的 3D 模型，速度也非常快，才能适应像手机解锁这样的应用 结构光方案因为自带光源，所以天黑的时候也能用 最大池化 max pooling https://blog.csdn.net/u012193416/article/details/79432668 池化操作时在卷积神经网络中经常采用过的一个基本操作，一般在卷积层后面都会接一个池化操作，但是近些年比较主流的ImageNet上的分类算法模型都是使用的max-pooling，很少使用average-pooling，这对我们平时设计模型时确实有比较重要的参考作用，但是原因在哪里呢？ 通常来讲，max-pooling的效果更好，虽然max-pooling和average-pooling都对数据做了下采样，但是max-pooling感觉更像是做了特征选择，选出了分类辨识度更好的特征，提供了非线性，根据相关理论，特征提取的误差主要来自两个方面： 邻域大小受限造成的估计值方差增大 卷积层参数误差造成估计均值的偏移 一般来说，average-pooling能减小第一种误差，更多的保留图像的背景信息，max-pooling能减小第二种误差，更多的保留纹理信息。average-pooling更强调对整体特征信息进行一层下采样，在减少参数维度的贡献上更大一点，更多的体现在信息的完整传递这个维度上，在一个很大很有代表性的模型中，比如说DenseNet中的模块之间的连接大多采用average-pooling，在减少维度的同时，更有利信息传递到下一个模块进行特征提取。 但是average-pooling在全局平均池化操作中应用也比较广，在ResNet和Inception结构中最后一层都使用了平均池化。有的时候在模型接近分类器的末端使用全局平均池化还可以代替Flatten操作，使输入数据变成一位向量。 max-pooling和average-pooling的使用性能对于我们设计卷积网络还是很有用的，虽然池化操作对于整体精度提升效果也不大，但是在减参，控制过拟合以及提高模型性能，节约计算力上的作用还是很明显的，所以池化操作时卷积设计上不可缺少的一个操作。]]></content>
      <tags>
        <tag>点云</tag>
      </tags>
  </entry>
</search>
